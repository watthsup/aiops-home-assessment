# TODO: Implement CI/CD pipeline
#
# This workflow should ensure code quality before deployment.
# Consider: What checks are necessary? How do you gate deployments?
#           How can someone verify a deployment occurred?
#
# The eval-runner service exists for a reason. The deployment/ directory
# contains a manifest that may be useful.
#
# TASK1 ANS: Overview — how this pipeline addresses the three requirements
# 1. "The pipeline should prevent broken builds from being merged"
#      - quality-gate job runs on every push and pull_request to main. 
#      - It builds agent-api and eval-runner. If either build fails, the job fails. 
#      - It then runs the agent-api and the eval runner. 
#      - Any step failure (build, health check, or eval exit 1) fails the job, so the PR check stays red and merge can be blocked by branch protection.
#
# 2. "Deployments should be traceable to specific commits"
#      - update-manifest job (only on push to main after quality-gate passes)
#      - It writes the commit SHA into deployment/manifest.yml as image_tag and appends a line to the Deployment History comment. 
#      - Anyone can see which commit a deployment corresponds to by reading the manifest.
#
# 3. "The eval runner plays a role in quality gates"
#      - The "Run evaluation (quality gate)" step runs the eval-runner container.
#      - The runner exits 0 only when golden accuracy and adversarial rejection thresholds are met; otherwise it exits 1. 
#      - The step has no explicit failure handling—GitHub Actions fails the step on non-zero exit, so the job fails and the pipeline does not pass until eval gates are met.

name: CI/CD Pipeline

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  # TODO: Design and implement your pipeline
  quality-gate:
    name: Build & Quality Gate
    runs-on: ubuntu-latest
    steps:
      # TASK1 ANS: Fetch repo contents to build images and run eval.
      - name: Checkout
        uses: actions/checkout@v4

      # TASK1 ANS: Fail early if agent-api does not build (broken Dockerfile/deps). Tag with SHA so the image is tied to this commit for traceability.
      - name: Build agent-api image
        run: docker build -t agent-api:${{ github.sha }} ./agent-api

      # TASK1 ANS: Eval-runner must be built from same commit to test the same code, build failure here also prevents merge.
      - name: Build eval-runner image
        run: docker build -t eval-runner:${{ github.sha }} ./eval-runner

      # TASK1 ANS: Eval-runner calls agent-api over HTTP. If API never becomes healthy, we exit 1 so the job fails.
      - name: Start agent-api
        run: |
          docker network create aiops-network 2>/dev/null || true
          docker run -d --name agent-api --network aiops-network -p 8080:8080 \
            -e PROMPT_VERSION=v1.0.0 \
            agent-api:${{ github.sha }}
          echo "Waiting for /healthz..."
          for i in $(seq 1 30); do
            if curl -sf http://localhost:8080/healthz >/dev/null; then
              echo "API ready."
              break
            fi
            if [ "$i" -eq 30 ]; then
              echo "API did not become ready in time."
              exit 1
            fi
            sleep 1
          done

      # TASK1 ANS: Eval runner is the quality gate—it exits 1 when golden/adversarial thresholds are not met. Step fails on non-zero exit, so the job fails and broken behavior cannot be merged.
      - name: Run evaluation (quality gate)
        run: |
          docker run --rm --network aiops-network \
            -e AGENT_API_URL=http://agent-api:8080 \
            eval-runner:${{ github.sha }}

  # TASK1 ANS: Only update manifest when code lands on main (deployment event). Needs quality-gate so we only record SHAs that passed build + eval.
  update-manifest:
    name: Update deployment manifest
    runs-on: ubuntu-latest
    needs: quality-gate
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    steps:
      # TASK1 ANS: Need write access to push manifest changes; GITHUB_TOKEN allows push to the same repo.
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      # TASK1 ANS: When we push a manifest-only commit, that triggers another run. Without this check we would update manifest again (new SHA) and push again, causing an infinite loop. Skip when the only changed file is the manifest.
      - name: Skip if commit only touched manifest
        id: skip
        run: |
          FILES=$(git show --name-only --pretty=format: HEAD | tail -n +2)
          if echo "$FILES" | grep -v 'deployment/manifest.yml' | grep -q .; then
            echo "run_update=true" >> $GITHUB_OUTPUT
          else
            echo "run_update=false" >> $GITHUB_OUTPUT
          fi

      # TASK1 ANS: Write commit SHA into image_tag and deployment history so deployments are traceable to a specific commit. Only commit if manifest does not already point to this SHA (idempotent for re-runs).
      - name: Update image_tag and deployment history
        if: steps.skip.outputs.run_update == 'true'
        run: |
          SHA="${{ github.sha }}"
          TS=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          if ! grep -q "image_tag: \"$SHA\"" deployment/manifest.yml; then
            sed -i "s/image_tag: \".*\"/image_tag: \"$SHA\"/" deployment/manifest.yml
            sed -i "$ i\\# | $TS | ${SHA:0:7} | github-actions |" deployment/manifest.yml
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add deployment/manifest.yml
            git commit -m "chore(deploy): record deployment for $SHA"
            git push origin main
          fi
